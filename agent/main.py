"""
Main Entry Point for Investment MCP Agent

This is the main entry point where the fastmcp agent is defined and 
the scheduled task is orchestrated.
"""

import logging
import asyncio
from datetime import datetime, timezone
from typing import Optional

from fastmcp import FastMCP

# Import our modules
from . import sheets_connector
from . import analysis
from . import storage
from . import reporting
from . import risk_analysis
from . import insider_trading
from . import short_volume
from .sell_validation import validate_sells_have_transactions, SellValidationError
from .buy_validation import validate_buys_have_transactions, BuyValidationError

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Create the MCP agent
mcp = FastMCP("Investment Portfolio Agent")


@mcp.tool()
def run_portfolio_analysis() -> str:
    """
    Manually trigger a portfolio analysis run.
    
    Returns:
        str: Analysis result message
    """
    try:
        return _run_weekly_analysis()
    except Exception as e:
        error_msg = f"Portfolio analysis failed: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_portfolio_status() -> str:
    """
    Get the current portfolio status from the latest snapshot.
    
    Returns:
        str: Current portfolio status
    """
    try:
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return "No portfolio snapshots available. Run analysis first."
        
        timestamp = latest_snapshot.get('timestamp', 'Unknown time')
        total_value = latest_snapshot.get('total_value_eur', 0.0)
        asset_count = len(latest_snapshot.get('assets', []))
        
        return f"""üìä Latest Portfolio Status
        
**Last Updated:** {timestamp}
**Total Value:** ‚Ç¨{total_value:,.2f}
**Number of Assets:** {asset_count}

Run portfolio analysis to generate a new snapshot and comparison report."""
        
    except Exception as e:
        error_msg = f"Failed to get portfolio status: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_portfolio_history_summary() -> str:
    """
    Get a summary of the portfolio history.
    
    Returns:
        str: Portfolio history summary
    """
    try:
        all_snapshots = storage.get_all_snapshots()
        
        if not all_snapshots:
            return "No portfolio history available."
        
        first_snapshot = all_snapshots[0]
        latest_snapshot = all_snapshots[-1]
        
        first_date = first_snapshot.get('timestamp', 'Unknown')
        latest_date = latest_snapshot.get('timestamp', 'Unknown')
        first_value = first_snapshot.get('total_value_eur', 0.0)
        latest_value = latest_snapshot.get('total_value_eur', 0.0)
        
        total_change = latest_value - first_value
        total_change_percent = (total_change / first_value * 100) if first_value > 0 else 0
        
        change_emoji = "üìà" if total_change >= 0 else "üìâ"
        change_sign = "+" if total_change >= 0 else ""
        
        return f"""üìà Portfolio History Summary

**Total Snapshots:** {len(all_snapshots)}
**First Snapshot:** {first_date}
**Latest Snapshot:** {latest_date}

**Performance Since Start:**
- Initial Value: ‚Ç¨{first_value:,.2f}
- Current Value: ‚Ç¨{latest_value:,.2f}
- Total Change: {change_emoji} {change_sign}‚Ç¨{total_change:,.2f} ({change_sign}{total_change_percent:.2f}%)"""
        
    except Exception as e:
        error_msg = f"Failed to get portfolio history: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_latest_positions() -> str:
    """
    Get all current portfolio positions organized by category.
    
    Fetches the latest portfolio snapshot and displays all positions
    grouped by asset category (Stocks, Bonds, ETFs, Pension, Cash) with
    detailed information including quantities, values, and gain/loss.
    
    Returns:
        str: Formatted list of all positions organized by category
    """
    try:
        logger.info("Fetching latest portfolio positions...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# üíº Current Portfolio Positions

No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Generated by Investment MCP Agent*"""
        
        organized_data = analysis.organize_positions_by_category(latest_snapshot)
        
        markdown_report = reporting.format_positions_markdown(organized_data)
        
        logger.info("Successfully retrieved latest positions")
        return markdown_report
        
    except Exception as e:
        error_msg = f"Failed to get latest positions: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üíº Current Portfolio Positions

## ‚ùå Error
{error_msg}

*Generated by Investment MCP Agent*"""


@mcp.tool()
def get_upcoming_events() -> str:
    """
     Get upcoming earnings reports for portfolio stocks.
     
     Returns upcoming earnings reports within the next 2 months, sorted chronologically.
     Events are fetched from Yahoo Finance API and matched against portfolio stocks
     using the ticker_mapping.json file.
    
    Returns:
        str: Formatted list of upcoming events or error message
    """
    try:
        from . import events_tracker
        
        logger.info("Fetching upcoming events for portfolio...")
        
        raw_data = sheets_connector.fetch_portfolio_data()
        normalized_data = sheets_connector.parse_and_normalize_data(raw_data)
        
        result = events_tracker.get_portfolio_upcoming_events(normalized_data)
        
        if not result.get("success", False):
            if result.get("unmapped_stocks"):
                error_lines = [result.get("error", "Error")]
                error_lines.extend(result.get("unmapped_stocks", []))
                error_lines.append("")
                error_lines.append(result.get("action", ""))
                return "\n".join(error_lines)
            else:
                return result.get("error", "Unknown error occurred")
        
        events = result.get("events", [])
        
        if not events:
            return """üìÖ Upcoming Earnings Reports

No upcoming earnings reports found within the next 2 months for your portfolio stocks.

**Note:** Ensure that:
1. All portfolio stocks are mapped in ticker_mapping.json
2. Your stocks have upcoming earnings announcements"""
        
        output_lines = ["üìÖ Upcoming Earnings Reports (Next 2 Months)", "", ""]
        
        for event in events:
            event_type = event.get("type", "")
            ticker = event.get("ticker", "")
            company = event.get("company_name", "")
            date = event.get("date", "")
            days_until = event.get("days_until", 0)
            
            output_lines.append(f"**{event_type}**")
            output_lines.append(f"- Ticker: {ticker}")
            output_lines.append(f"- Company: {company}")
            output_lines.append(f"- Date: {date} ({days_until} days)")
            
            if event_type == "Earnings Report":
                estimate = event.get("estimate")
                if estimate:
                    output_lines.append(f"- Estimate: {estimate}")
            
            output_lines.append("")
        
        output_lines.append(f"**Summary:**")
        output_lines.append(f"- Total Reports: {result.get('total_events', 0)}")
        output_lines.append(f"- Earnings Reports: {result.get('earnings_count', 0)}")
        output_lines.append(f"- Data Source: {result.get('provider', 'Unknown')}")
        output_lines.append(f"- Last Updated: {result.get('as_of', 'Unknown')}")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get upcoming events: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return error_msg


@mcp.tool()
def get_earnings_date(ticker: str) -> str:
    """
    Get the next earnings date for a specific stock ticker.
    
    Fetches the upcoming earnings report date for any stock ticker symbol
    using Yahoo Finance API. No API key required.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
    
    Returns:
        str: Formatted earnings date information or error message
    """
    try:
        from . import events_tracker
        
        logger.info(f"Fetching earnings date for {ticker}...")
        
        result = events_tracker.get_earnings_for_ticker(ticker)
        
        if not result.get("success", False):
            return f"""# üìÖ Earnings Date - {ticker}

## ‚ùå Error
{result.get('error', 'Unknown error occurred')}

*Data provided by Yahoo Finance*"""
        
        days_until = result.get("days_until", 0)
        report_date = result.get("report_date", "Unknown")
        company_name = result.get("company_name", ticker)
        estimate = result.get("estimate")
        
        output_lines = [
            f"# üìÖ Earnings Date - {ticker}",
            "",
            f"**Company:** {company_name}",
            f"**Report Date:** {report_date}",
            f"**Days Until:** {days_until} days",
            "",
        ]
        
        if estimate:
            output_lines.append(f"**Earnings Estimate:** ${estimate:.2f}")
            output_lines.append("")
        
        fiscal_period = result.get("fiscal_period")
        if fiscal_period:
            output_lines.append(f"**Fiscal Period:** {fiscal_period}")
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**Data Source:** {result.get('source', 'Unknown')}")
        output_lines.append(f"**Last Updated:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by Yahoo Finance*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get earnings date: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìÖ Earnings Date - {ticker}

## ‚ùå Error
{error_msg}

*Data provided by Yahoo Finance*"""


@mcp.tool()
def analyze_portfolio_risk() -> str:
    """
    Perform comprehensive risk analysis on the current portfolio.
    
    Calculates:
    - Portfolio beta (market sensitivity)
    - Value at Risk (VaR) at 95% and 99% confidence
    - Concentration risk score and HHI
    - Correlation matrix between holdings
    - Sector/geography exposure breakdown
    - Volatility by asset class
    - Downside risk metrics (Sortino, max drawdown, CVaR)
    
    This analysis fetches historical price data from Alpha Vantage API
    and may take several minutes to complete due to API rate limits.
    
    Returns:
        str: Formatted markdown risk analysis report
    """
    try:
        logger.info("Starting portfolio risk analysis...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# üìä Portfolio Risk Analysis

## ‚ùå Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Risk analysis generated by Investment MCP Agent*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# üìä Portfolio Risk Analysis

## ‚ùå Error
No assets found in portfolio snapshot.

*Risk analysis generated by Investment MCP Agent*"""
        
        logger.info(f"Analyzing risk for {len(portfolio_assets)} portfolio assets...")
        
        risk_data = risk_analysis.analyze_portfolio_risk(portfolio_assets)
        
        markdown_report = reporting.format_risk_report_markdown(risk_data)
        
        logger.info("Portfolio risk analysis completed successfully")
        return markdown_report
        
    except Exception as e:
        error_msg = f"Risk analysis failed: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìä Portfolio Risk Analysis

## ‚ùå Error
{error_msg}

Please check:
- Alpha Vantage API key is configured
- Ticker mappings are complete in ticker_mapping.json
- Portfolio has sufficient data

*Risk analysis generated by Investment MCP Agent*"""


@mcp.tool()
def get_insider_trades(ticker: str) -> str:
    """
    Get insider trading activity for a specific stock ticker.
    
    Fetches and analyzes insider trades (buys, sells, option exercises) for 
    the specified ticker over the last 90 days. Provides buy/sell statistics,
    sentiment analysis, and recent transaction details.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
    
    Returns:
        str: Formatted insider trading report with statistics and recent trades
    """
    try:
        logger.info(f"Fetching insider trades for {ticker}...")
        
        result = insider_trading.get_insider_trades_for_ticker(ticker)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            return f"""# üìä Insider Trading - {ticker}

## ‚ùå Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        if result['total_trades'] == 0:
            return f"""# üìä Insider Trading - {ticker}

No insider trading activity found in the last 90 days.

**Data URL:** {result.get('url', 'N/A')}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        stats = result['statistics']
        
        output_lines = [
            f"# üìä Insider Trading - {ticker}",
            "",
            "## Summary (Last 90 Days)",
            "",
            f"**Total Transactions:** {result['total_trades']}",
            f"**Buy Transactions:** {stats['total_buys']}",
            f"**Sell Transactions:** {stats['total_sells']}",
            "",
            f"**Total Buy Value:** ${stats['buy_value_usd']:,.2f}",
            f"**Total Sell Value:** ${stats['sell_value_usd']:,.2f}",
            f"**Net Sentiment:** {stats['net_sentiment']}",
            "",
        ]
        
        if result['trades']:
            output_lines.append("## Recent Transactions")
            output_lines.append("")
            
            for trade in result['trades'][:10]:
                code = trade.get('code', 'Unknown')
                date = trade.get('transactionDate', trade.get('fileDate', 'Unknown'))
                insider = trade.get('name', 'Unknown')
                shares = trade.get('shares', 0)
                value = trade.get('value', 0)
                
                output_lines.append(f"**{date}** - {insider}")
                output_lines.append(f"- Type: {code}")
                output_lines.append(f"- Shares: {shares:,.0f}")
                if value:
                    output_lines.append(f"- Value: ${value:,.2f}")
                output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**Data URL:** {result.get('url', 'N/A')}")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get insider trades: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìä Insider Trading - {ticker}

## ‚ùå Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_portfolio_insider_trades() -> str:
    """
    Get insider trading activity for all stocks in the portfolio.
    
    Analyzes insider trading for all portfolio stocks over the last 90 days.
    Shows which stocks have significant insider buying or selling activity,
    organized by sentiment (Bullish/Neutral/Bearish).
    
    Note: Only analyzes stocks (excludes bonds, ETFs, pension, cash positions).
    Uses ticker_mapping.json to map portfolio stock names to ticker symbols.
    
    Returns:
        str: Formatted insider trading summary for entire portfolio
    """
    try:
        logger.info("Fetching insider trades for portfolio...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# üìä Portfolio Insider Trading

## ‚ùå Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# üìä Portfolio Insider Trading

## ‚ùå Error
No assets found in portfolio snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        result = insider_trading.get_portfolio_insider_trades(portfolio_assets)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            
            if result.get('unmapped_stocks'):
                unmapped_list = "\n".join([f"- {stock}" for stock in result['unmapped_stocks']])
                return f"""# üìä Portfolio Insider Trading

## ‚ùå Error
{error_msg}

**Unmapped stocks:**
{unmapped_list}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
            
            return f"""# üìä Portfolio Insider Trading

## ‚ùå Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        output_lines = [
            "# üìä Portfolio Insider Trading Analysis",
            "",
            "## Summary (Last 90 Days)",
            "",
            f"**Stocks Analyzed:** {result.get('stocks_analyzed', 0)}",
            f"**Stocks with Activity:** {result.get('stocks_with_activity', 0)}",
            f"**Total Transactions:** {result.get('total_transactions', 0)}",
            "",
        ]
        
        by_sentiment = result.get('by_sentiment', {})
        
        for sentiment in ['Bullish', 'Neutral', 'Bearish']:
            stocks = by_sentiment.get(sentiment, [])
            if stocks:
                sentiment_emoji = "üü¢" if sentiment == "Bullish" else "üü°" if sentiment == "Neutral" else "üî¥"
                output_lines.append(f"## {sentiment_emoji} {sentiment} Sentiment")
                output_lines.append("")
                
                for stock_data in stocks:
                    ticker = stock_data.get('ticker', 'Unknown')
                    stats = stock_data.get('statistics', {})
                    
                    output_lines.append(f"### {ticker}")
                    output_lines.append(f"- Transactions: {stock_data.get('total_trades', 0)}")
                    output_lines.append(f"- Buys: {stats.get('total_buys', 0)} (${stats.get('buy_value_usd', 0):,.2f})")
                    output_lines.append(f"- Sells: {stats.get('total_sells', 0)} (${stats.get('sell_value_usd', 0):,.2f})")
                    output_lines.append("")
        
        stocks_no_activity = result.get('stocks_no_activity', [])
        if stocks_no_activity:
            output_lines.append("## No Recent Activity")
            output_lines.append("")
            output_lines.append(", ".join(stocks_no_activity))
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get portfolio insider trades: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìä Portfolio Insider Trading

## ‚ùå Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_short_volume(ticker: str, days: int = 30) -> str:
    """
    Get short volume data for a specific stock ticker.
    
    Shows daily short selling activity over the specified period,
    including short volume ratio, trends, and risk assessment based
    on short selling patterns.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
        days: Number of days to look back (default: 30)
    
    Returns:
        str: Formatted short volume report with metrics and analysis
    """
    try:
        logger.info(f"Fetching short volume for {ticker}...")
        
        result = short_volume.get_short_volume_for_ticker(ticker, days)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            return f"""# üìä Short Volume Analysis - {ticker}

## ‚ùå Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        if result.get('metrics', {}).get('data_points', 0) == 0:
            return f"""# üìä Short Volume Analysis - {ticker}

No short volume data available for this ticker.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        metrics = result['metrics']
        
        output_lines = [
            f"# üìä Short Volume Analysis - {ticker}",
            "",
            f"## Current Metrics ({metrics['data_points']} days)",
            "",
            f"**Average Short Ratio:** {metrics['avg_short_ratio']:.2f}%",
            f"**Latest Short Ratio:** {metrics['latest_short_ratio']:.2f}% ({metrics['latest_date']})",
            f"**7-Day Average:** {metrics['avg_7day']:.2f}%",
            f"**30-Day Average:** {metrics['avg_30day']:.2f}%",
            "",
            f"**Trend:** {metrics['trend']}",
            "",
        ]
        
        risk = result.get('risk_analysis', {})
        if risk:
            output_lines.append("## Risk Assessment")
            output_lines.append("")
            output_lines.append(f"**Risk Level:** {risk['risk_emoji']} {risk['risk_level']}")
            output_lines.append(f"**Description:** {risk['description']}")
            if risk.get('factors'):
                output_lines.append("")
                output_lines.append("**Factors:**")
                for factor in risk['factors']:
                    output_lines.append(f"- {factor}")
            output_lines.append("")
        
        data_records = result.get('data', [])
        if data_records:
            sorted_records = sorted(data_records, key=lambda x: x.get('marketDate', ''), reverse=True)
            output_lines.append("## Recent Activity (Last 5 Days)")
            output_lines.append("")
            
            for record in sorted_records[:5]:
                date = record.get('marketDate', 'Unknown')
                short_vol = record.get('shortVolume', 0)
                total_vol = record.get('totalVolume', 0)
                ratio = record.get('shortVolumeRatio', 0) * 100
                
                output_lines.append(f"**{date}**")
                output_lines.append(f"- Short Volume: {short_vol:,} shares")
                output_lines.append(f"- Total Volume: {total_vol:,} shares")
                output_lines.append(f"- Short Ratio: {ratio:.2f}%")
                output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get short volume: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìä Short Volume Analysis - {ticker}

## ‚ùå Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_portfolio_short_analysis() -> str:
    """
    Analyze short selling activity across all portfolio stocks.
    
    Identifies stocks with high short volume ratios, unusual short
    selling patterns, and potential risks. Organizes results by risk
    level (High/Medium/Low) based on short volume patterns.
    
    Note: Only analyzes stocks (excludes bonds, ETFs, pension, cash).
    Uses ticker_mapping.json to map portfolio stock names to tickers.
    
    Returns:
        str: Formatted portfolio-wide short volume analysis
    """
    try:
        logger.info("Fetching short volume analysis for portfolio...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# üìä Portfolio Short Volume Analysis

## ‚ùå Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# üìä Portfolio Short Volume Analysis

## ‚ùå Error
No assets found in portfolio snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        result = short_volume.get_portfolio_short_analysis(portfolio_assets)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            
            if result.get('unmapped_stocks'):
                unmapped_list = "\n".join([f"- {stock}" for stock in result['unmapped_stocks']])
                return f"""# üìä Portfolio Short Volume Analysis

## ‚ùå Error
{error_msg}

**Unmapped stocks:**
{unmapped_list}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
            
            return f"""# üìä Portfolio Short Volume Analysis

## ‚ùå Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        output_lines = [
            "# üìä Portfolio Short Volume Analysis",
            "",
            "## Summary",
            "",
            f"**Stocks Analyzed:** {result.get('stocks_analyzed', 0)}",
            f"**Stocks with Data:** {result.get('stocks_with_data', 0)}",
            f"**Average Short Ratio:** {result.get('avg_short_ratio', 0):.2f}%",
            "",
            f"**High Risk Stocks:** {result.get('high_risk_count', 0)}",
            f"**Medium Risk Stocks:** {result.get('medium_risk_count', 0)}",
            f"**Low Risk Stocks:** {result.get('low_risk_count', 0)}",
            "",
        ]
        
        by_risk = result.get('by_risk', {})
        
        if by_risk.get('high'):
            output_lines.append("## üî¥ High Risk (Elevated Short Activity)")
            output_lines.append("")
            
            for stock_data in by_risk['high']:
                ticker = stock_data.get('ticker', 'Unknown')
                metrics = stock_data.get('metrics', {})
                risk = stock_data.get('risk_analysis', {})
                
                output_lines.append(f"### {ticker}")
                output_lines.append(f"- Average Short Ratio: {metrics.get('avg_short_ratio', 0):.2f}%")
                output_lines.append(f"- Trend: {metrics.get('trend', 'Unknown')}")
                output_lines.append(f"- Risk: {risk.get('description', 'Unknown')}")
                if risk.get('factors'):
                    for factor in risk['factors']:
                        output_lines.append(f"  - {factor}")
                output_lines.append("")
        
        if by_risk.get('medium'):
            output_lines.append("## üü° Medium Risk (Moderate Short Activity)")
            output_lines.append("")
            
            for stock_data in by_risk['medium']:
                ticker = stock_data.get('ticker', 'Unknown')
                metrics = stock_data.get('metrics', {})
                
                output_lines.append(f"### {ticker}")
                output_lines.append(f"- Average Short Ratio: {metrics.get('avg_short_ratio', 0):.2f}%")
                output_lines.append(f"- Trend: {metrics.get('trend', 'Unknown')}")
                output_lines.append("")
        
        if by_risk.get('low'):
            output_lines.append("## üü¢ Low Risk (Normal Short Activity)")
            output_lines.append("")
            low_tickers = [s.get('ticker', 'Unknown') for s in by_risk['low']]
            output_lines.append(", ".join(low_tickers[:10]))
            if len(low_tickers) > 10:
                output_lines.append(f"... and {len(low_tickers) - 10} more")
            output_lines.append("")
        
        stocks_no_data = result.get('stocks_no_data', [])
        if stocks_no_data:
            output_lines.append("## No Data Available")
            output_lines.append("")
            output_lines.append(", ".join(stocks_no_data))
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get portfolio short analysis: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìä Portfolio Short Volume Analysis

## ‚ùå Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def generate_portfolio_dashboard(view: str = "daily", time_period: str = "all") -> str:
    """
    Generate interactive HTML dashboard with portfolio visualizations.

    Creates a dashboard with different views optimized for various analysis needs.

    Args:
        view: Dashboard view - "daily" (quick check-in), "performance" (trends),
              "transactions" (trading history), "risk" (deep analysis) (default: "daily")
        time_period: One of "7d", "30d", "90d", "1y", "all" (default: "all")

    Returns:
        str: Path to generated HTML file with instructions to open
    """
    try:
        from . import visualization

        logger.info(f"Generating portfolio dashboard - view: {view}, period: {time_period}")

        result = visualization.generate_portfolio_dashboard(view, time_period)
        
        if not result.get("success"):
            return f"""# üìä Portfolio Dashboard Generation Failed
            
## ‚ùå Error
{result.get('error', 'Unknown error occurred')}

*Dashboard generation by Investment MCP Agent*"""
        
        file_path = result.get("file_path")
        file_url = result.get("file_url")
        snapshot_count = result.get("snapshot_count", 0)
        date_range = result.get("date_range", {})
        
        view_type = result.get("view", view)

        # View-specific descriptions
        view_descriptions = {
            "daily": [
                "- **KPI Cards:** Total value, daily change, return %, winners count",
                "- **Top Movers:** Attribution analysis showing which assets drove changes",
                "- **7-Day Trend:** Portfolio value sparkline",
                "- **Risk Summary:** Key metrics at a glance"
            ],
            "performance": [
                "- **Portfolio Value Trend** (vs S&P 500 & All-World Index)",
                "- **Category Allocation Over Time** (stacked areas)",
                "- **Individual Asset Performance** (multi-line chart)",
                "- **Gain/Loss Analysis** (current positions)",
                "- **HHI Concentration Trend** (diversification tracking)"
            ],
            "transactions": [
                "- **Transaction Timeline** (buy/sell activity with markers)",
                "- **Realized Gains Tracker** (cumulative and monthly P&L)"
            ],
            "risk": [
                "- **Risk Metrics Dashboard** (returns, drawdown, volatility)",
                "- **Distribution Analysis** (value change histogram)"
            ]
        }

        output_lines = [
            f"# ‚úÖ Portfolio Dashboard Generated Successfully! ({view_type.title()} View)",
            "",
            "## üìä Dashboard Location",
            f"**File Path:** `{file_path}`",
            f"**URL:** {file_url}",
            "",
            "### To Open:",
            "- Click the URL above (in supported clients)",
            f"- Or run: `open {file_path}`",
            "",
            f"## üìà {view_type.title()} View Includes:",
        ]

        output_lines.extend(view_descriptions.get(view_type, ["- Dashboard visualizations"]))

        output_lines.extend([
            "",
            "## üìÖ Data Range:",
            f"- **View:** {view_type}",
            f"- **Period:** {time_period}",
            f"- **Start Date:** {date_range.get('start', 'N/A')}",
            f"- **End Date:** {date_range.get('end', 'N/A')}",
            f"- **Snapshots:** {snapshot_count}",
            "",
            "## üéõÔ∏è Interactive Features:",
            "- **Zoom & Pan:** Interactive chart controls",
            "- **Hover Details:** Detailed tooltips on all data points",
            "- **Toggle Series:** Click legend items to show/hide",
            "",
            "---",
            f"*Generated at: {result.get('generated_at', 'Unknown')}*",
            "*Dashboard by Investment MCP Agent*"
        ])
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to generate dashboard: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìä Portfolio Dashboard Generation Failed

## ‚ùå Error
{error_msg}

*Dashboard generation by Investment MCP Agent*"""


@mcp.tool()
def get_daily_overview() -> str:
    """
    Get daily portfolio overview with today's changes and top movers.

    Quick check-in tool optimized for seeing what changed today. Shows KPI metrics,
    attribution analysis (which assets drove the change), and win/loss ratio.

    Requires yesterday's snapshot to exist for comparison.

    Returns:
        str: Daily overview summary with KPIs and top movers
    """
    try:
        from . import storage, daily_analysis

        logger.info("Fetching daily portfolio overview...")

        # Get today's and yesterday's snapshots
        all_snapshots = storage.get_all_snapshots()

        if not all_snapshots:
            return """# üìä Daily Overview

## ‚ö†Ô∏è No Data Available
No portfolio snapshots found. Run portfolio analysis first.

*Daily Overview by Investment MCP Agent*"""

        today_snapshot = all_snapshots[-1]
        yesterday_snapshot = daily_analysis.get_yesterday_snapshot()

        if not yesterday_snapshot:
            # Show current status without comparison
            total_value = today_snapshot.get("total_value_eur", 0)
            timestamp = today_snapshot.get("timestamp", "Unknown")

            return f"""# üìä Daily Overview

## üíº Current Portfolio Status
**Total Value:** ‚Ç¨{total_value:,.2f}
**Snapshot Time:** {timestamp}

## ‚ö†Ô∏è No Daily Comparison Available
Yesterday's snapshot not found. Daily changes require a snapshot from the previous day.

Run portfolio analysis tomorrow to see daily changes and attribution.

*Daily Overview by Investment MCP Agent*"""

        # Calculate daily changes
        daily_data = daily_analysis.calculate_daily_changes(today_snapshot, yesterday_snapshot)

        # Calculate attribution
        attribution = daily_analysis.calculate_attribution(
            daily_data["asset_changes"],
            daily_data["total_change_eur"]
        )

        # Get win/loss ratio
        win_loss = daily_analysis.get_win_loss_ratio(daily_data["asset_changes"])

        # Format output
        output_lines = [
            "# üìä Daily Portfolio Overview",
            "",
            "## üíº Key Metrics",
            f"**Total Value:** ‚Ç¨{daily_data['today_value_eur']:,.2f}",
            f"**Daily Change:** ‚Ç¨{daily_data['total_change_eur']:+,.2f} ({daily_data['total_change_pct']:+.2f}%)",
            f"**Winners:** {win_loss['winners']}/{win_loss['total']} positions ({win_loss['win_ratio']:.0f}%)",
            f"**Losers:** {win_loss['losers']}/{win_loss['total']} positions",
            "",
            "## üìà Top 5 Movers (by contribution to change)",
            ""
        ]

        # Add top 5 movers
        top_movers = attribution[:5]
        for i, mover in enumerate(top_movers, 1):
            icon = "üü¢" if mover["is_gainer"] else "üî¥"
            output_lines.append(
                f"{i}. {icon} **{mover['name']}**: ‚Ç¨{abs(mover['change_eur']):,.2f} "
                f"({mover['change_pct']:+.1f}%) - {abs(mover['contribution_pct']):.0f}% of total change"
            )

        output_lines.extend([
            "",
            "## üìÖ Period",
            f"**Yesterday:** {daily_data.get('timestamp_yesterday', 'Unknown')}",
            f"**Today:** {daily_data.get('timestamp_today', 'Unknown')}",
            "",
            "---",
            "*For detailed visualizations, use: `generate_portfolio_dashboard(view='daily')`*",
            "*Daily Overview by Investment MCP Agent*"
        ])

        return "\n".join(output_lines)

    except Exception as e:
        error_msg = f"Failed to get daily overview: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìä Daily Overview Failed

## ‚ùå Error
{error_msg}

*Daily Overview by Investment MCP Agent*"""


@mcp.tool()
def get_storage_status() -> str:
    """
    Get the current storage backend status.
    
    Shows whether GCP is available, sync status, and any pending uploads.
    Useful for debugging storage issues or verifying cloud sync.
    
    Returns:
        str: Storage status information
    """
    try:
        logger.info("Fetching storage backend status...")
        
        status = storage.get_storage_status()
        
        output_lines = ["# üíæ Storage Backend Status", ""]
        
        backend_type = status.get("backend_type", "Unknown")
        available = status.get("available", False)
        
        output_lines.append(f"**Backend Type:** {backend_type}")
        output_lines.append(f"**Available:** {'‚úÖ Yes' if available else '‚ùå No'}")
        output_lines.append("")
        
        # Hybrid storage details
        if "primary_available" in status:
            output_lines.append("## Hybrid Storage Details")
            output_lines.append("")
            
            primary_avail = status.get('primary_available', False)
            fallback_avail = status.get('fallback_available', False)
            pending_syncs = status.get('pending_syncs', 0)
            fully_synced = status.get('fully_synced', False)
            
            output_lines.append(f"**Primary (GCP):** {'‚úÖ Available' if primary_avail else '‚ùå Unavailable'}")
            output_lines.append(f"**Fallback (Local):** {'‚úÖ Available' if fallback_avail else '‚ùå Unavailable'}")
            output_lines.append(f"**Pending Syncs:** {pending_syncs}")
            output_lines.append(f"**Fully Synced:** {'‚úÖ Yes' if fully_synced else '‚ö†Ô∏è No'}")
            output_lines.append("")
            
            if pending_syncs > 0:
                output_lines.append("‚ö†Ô∏è **Warning:** Some snapshots are queued for GCP upload")
                output_lines.append("They will be automatically synced when GCP becomes available")
                output_lines.append("")
            
            if fully_synced and primary_avail:
                output_lines.append("‚úÖ **All Good:** Portfolio data is synced to cloud storage")
                output_lines.append("")
        
        # Error handling
        if "error" in status:
            output_lines.append("## ‚ùå Error")
            output_lines.append("")
            output_lines.append(f"Failed to get storage status: {status['error']}")
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append("")
        output_lines.append("**Storage Location:**")
        output_lines.append("- Primary: `gs://investment_snapshots/portfolio_history.json`")
        output_lines.append("- Fallback: `./portfolio_history.json`")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get storage status: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üíæ Storage Backend Status

## ‚ùå Error
{error_msg}

*Generated by Investment MCP Agent*"""


@mcp.tool()
def list_snapshots() -> str:
    """
    List all portfolio snapshots with index and timestamp.
    
    Displays a simple table showing the index number and timestamp for each snapshot.
    Use this to identify which snapshot to delete.
    
    Returns:
        str: Formatted table of snapshots
    """
    try:
        logger.info("Listing all portfolio snapshots...")
        
        snapshots = storage.list_snapshots()
        
        if not snapshots:
            return """# üìã Portfolio Snapshots

No snapshots found in portfolio history.

Run `run_portfolio_analysis()` to create your first snapshot.

*Generated by Investment MCP Agent*"""
        
        output_lines = [
            "# üìã Portfolio Snapshots",
            "",
            f"**Total Snapshots:** {len(snapshots)}",
            "",
            "| Index | Timestamp           | Total Value (EUR) | Assets |",
            "|-------|---------------------|-------------------|--------|"
        ]
        
        for snapshot in snapshots:
            timestamp_str = snapshot["timestamp"]
            # Format timestamp for display (remove timezone for readability)
            if "T" in timestamp_str:
                date_part, time_part = timestamp_str.split("T")
                time_part = time_part.split("+")[0].split("Z")[0]  # Remove timezone
                display_time = f"{date_part} {time_part}"
            else:
                display_time = timestamp_str
            
            output_lines.append(
                f"| {snapshot['index']:5d} | {display_time:19s} | ‚Ç¨{snapshot['total_value_eur']:>15,.2f} | {snapshot['asset_count']:6d} |"
            )
        
        output_lines.extend([
            "",
            "---",
            "",
            "**Usage:**",
            "- To delete a snapshot: `delete_snapshot(index=N, confirm=True)`",
            "- Example: `delete_snapshot(index=5, confirm=True)`",
            "",
            "*Generated by Investment MCP Agent*"
        ])
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to list snapshots: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# üìã Portfolio Snapshots

## ‚ùå Error
{error_msg}

*Generated by Investment MCP Agent*"""


@mcp.tool()
def delete_snapshot(index: int, confirm: bool = False) -> str:
    """
    Delete a specific snapshot from portfolio history.
    
    **‚ö†Ô∏è WARNING:** This operation permanently deletes data from both GCP and local storage.
    A timestamped backup is created before deletion.
    
    Args:
        index: 1-based index of snapshot to delete (use list_snapshots() to see indices)
        confirm: Must be True to execute deletion (safety check)
    
    Examples:
        delete_snapshot(index=5, confirm=True)
        delete_snapshot(index=1, confirm=True)
    
    Returns:
        str: Deletion status message with backup information
    """
    try:
        logger.info(f"Delete snapshot request: index={index}, confirm={confirm}")
        
        result = storage.delete_snapshot(index=index, confirm=confirm)
        
        if not result["success"]:
            # Check if it's a confirmation error or other error
            if "confirm=True" in result.get("error", ""):
                # Get snapshot info for warning
                snapshots = storage.list_snapshots()
                if index > 0 and index <= len(snapshots):
                    snapshot_info = snapshots[index - 1]
                    return f"""# ‚ö†Ô∏è  Deletion Confirmation Required

**You are about to permanently delete:**
- **Index:** {snapshot_info['index']}
- **Timestamp:** {snapshot_info['timestamp']}
- **Total Value:** ‚Ç¨{snapshot_info['total_value_eur']:,.2f}
- **Assets:** {snapshot_info['asset_count']}

**This action will:**
- Delete the snapshot from GCP Cloud Storage
- Delete the snapshot from local storage
- Create timestamped backups before deletion
- **Cannot be undone** (except by restoring from backup)

**To confirm deletion, run:**
```
delete_snapshot(index={index}, confirm=True)
```

*Generated by Investment MCP Agent*"""
            
            # Other error
            return f"""# ‚ùå Snapshot Deletion Failed

{result.get('error', 'Unknown error')}

{result.get('warning', '')}

*Generated by Investment MCP Agent*"""
        
        # Success
        deleted = result["deleted_snapshot"]
        remaining = result["remaining_count"]
        
        return f"""# ‚úÖ Snapshot Deleted Successfully

**Deleted Snapshot:**
- **Index:** {deleted['index']}
- **Timestamp:** {deleted['timestamp']}
- **Total Value:** ‚Ç¨{deleted['total_value_eur']:,.2f}
- **Assets:** {deleted['asset_count']}

**Backups Created:**
- Local: `./portfolio_history.json.bak.<timestamp>`
- GCP: `gs://bucket/portfolio_history.json.bak.<timestamp>`

**Remaining Snapshots:** {remaining}

Run `list_snapshots()` to see updated list.

*Generated by Investment MCP Agent*"""
        
    except Exception as e:
        error_msg = f"Failed to delete snapshot: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ‚ùå Snapshot Deletion Failed

## Error
{error_msg}

*Generated by Investment MCP Agent*"""


def _run_weekly_analysis() -> str:
    """
    Core function that performs the weekly portfolio analysis workflow.
    NOW INCLUDES: Automatic dashboard generation.
    
    Returns:
        str: Result message
    """
    try:
        logger.info("Starting weekly portfolio analysis...")
        
        # Get the previous snapshot
        previous_snapshot = storage.get_latest_snapshot()
        
        # Fetch and normalize current portfolio data
        logger.info("Fetching portfolio data from Google Sheets...")
        raw_data = sheets_connector.fetch_portfolio_data()
        normalized_data = sheets_connector.parse_and_normalize_data(raw_data)
        
        # Fetch and parse transactions from Google Sheets
        logger.info("Fetching transactions from Transactions sheet...")
        try:
            # Extract currency rates from portfolio data
            rates = raw_data.get("rates", [])
            gbp_to_eur = float(rates[0][0]) if len(rates) > 0 and rates[0] else 1.1589
            usd_to_eur = float(rates[1][0]) if len(rates) > 1 and rates[1] else 0.8490
            currency_rates = {
                "gbp_to_eur": gbp_to_eur,
                "usd_to_eur": usd_to_eur
            }
            
            # Fetch sell transactions
            transactions_raw = sheets_connector.fetch_transactions_data()
            sell_transactions = sheets_connector.parse_transactions(transactions_raw, gbp_to_eur, usd_to_eur)
            logger.info(f"Fetched {len(sell_transactions)} sell transaction(s) from Transactions sheet")
            
            # Fetch buy transactions
            buy_transactions_raw = sheets_connector.fetch_buy_transactions_data()
            buy_transactions = sheets_connector.parse_buy_transactions(buy_transactions_raw, gbp_to_eur, usd_to_eur)
            logger.info(f"Fetched {len(buy_transactions)} buy transaction(s) from Transactions sheet")
        except Exception as e:
            error_msg = f"Failed to load transactions: {e}"
            logger.error(error_msg)
            return f"‚ùå {error_msg}\n\nTransactions sheet is required for transaction validation. Please ensure the Transactions sheet exists in your Google Sheets workbook."
        
        # Create new snapshot (WITHOUT embedded transactions)
        logger.info("Creating portfolio snapshot...")
        current_snapshot = analysis.create_portfolio_snapshot(normalized_data)
        
        # VALIDATE: Check sells and buys have matching transactions (if previous snapshot exists)
        if previous_snapshot:
            logger.info("Validating sell transactions...")
            try:
                validate_sells_have_transactions(
                    current_snapshot=current_snapshot,
                    previous_snapshot=previous_snapshot,
                    transactions=sell_transactions
                )
                logger.info("‚úì Sell validation passed")
            except SellValidationError as e:
                # Validation failed - do NOT save snapshot or transactions
                logger.error("Sell validation failed")
                return str(e)
            
            logger.info("Validating buy transactions...")
            try:
                validate_buys_have_transactions(
                    current_snapshot=current_snapshot,
                    previous_snapshot=previous_snapshot,
                    buy_transactions=buy_transactions
                )
                logger.info("‚úì Buy validation passed")
            except BuyValidationError as e:
                # Validation failed - do NOT save snapshot or transactions
                logger.error("Buy validation failed")
                return str(e)
        else:
            logger.info("First snapshot, skipping transaction validation")
        
        # Validation passed - save transactions (only if changed)
        logger.info("Saving transactions to storage...")
        transactions_saved = storage.save_transactions(
            sell_transactions=sell_transactions,
            buy_transactions=buy_transactions,
            currency_rates=currency_rates
        )
        if transactions_saved:
            logger.info("‚úì Transactions saved (changed)")
        else:
            logger.info("‚úì Transactions unchanged (not saved)")
        
        # Save the snapshot
        storage.save_snapshot(current_snapshot)
        logger.info("Snapshot saved successfully")
        
        # Generate dashboard after snapshot is saved
        dashboard_link = ""
        try:
            from . import visualization
            logger.info("Generating portfolio dashboard...")
            dashboard_result = visualization.generate_portfolio_dashboard(
                time_period="all",
                force_regenerate=True
            )
            if dashboard_result.get("success"):
                dashboard_path = dashboard_result.get("file_path")
                dashboard_url = dashboard_result.get("file_url")
                logger.info(f"Dashboard generated: {dashboard_path}")
                dashboard_link = f"\n\n---\n\nüìä **Interactive Dashboard:** {dashboard_url}\n\nOpen in browser to explore interactive charts and metrics.\n"
            else:
                logger.warning(f"Dashboard generation failed: {dashboard_result.get('error')}")
        except Exception as e:
            logger.error(f"Failed to generate dashboard: {e}", exc_info=False)
            # Don't fail the entire analysis if dashboard generation fails
        
        # If we have a previous snapshot, perform comparison
        if previous_snapshot:
            logger.info("Performing week-over-week comparison...")
            report_data = analysis.compare_snapshots(
                current_snapshot,
                previous_snapshot,
                sell_transactions,
                buy_transactions
            )
            
            # Generate markdown report
            current_total_value = current_snapshot.get('total_value_eur', 0.0)
            markdown_report = reporting.format_report_markdown(
                report_data, 
                current_total_value, 
                current_snapshot,
                previous_snapshot
            )
            
            # Add dashboard link to report
            markdown_report += dashboard_link
            
            logger.info("Weekly analysis completed successfully")
            return markdown_report
        else:
            # First run
            current_total_value = current_snapshot.get('total_value_eur', 0.0)
            first_run_message = f"""# üìä Portfolio Tracking Initialized

**Initial Portfolio Value:** ‚Ç¨{current_total_value:,.2f}
**Assets Tracked:** {len(normalized_data)}
**Timestamp:** {current_snapshot.get('timestamp', 'Unknown')}

This is the first snapshot of your portfolio. Weekly comparison reports will be available starting next week.
"""
            
            # Add dashboard note
            if dashboard_link:
                first_run_message += dashboard_link
            else:
                first_run_message += "\n\nüìä **Dashboard:** Not enough data yet (need 2+ snapshots)\n"
            
            first_run_message += "\n---\n*Report generated automatically by Investment MCP Agent*"
            
            logger.info("First portfolio snapshot created successfully")
            return first_run_message
            
    except Exception as e:
        error_msg = f"Weekly analysis failed: {str(e)}"
        logger.error(error_msg, exc_info=True)
        raise


if __name__ == "__main__":
    # For testing purposes, you can run the analysis directly
    try:
        result = _run_weekly_analysis()
        print(result)
    except Exception as e:
        print(f"Error: {e}")