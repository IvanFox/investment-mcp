"""
Main Entry Point for Investment MCP Agent

This is the main entry point where the fastmcp agent is defined and 
the scheduled task is orchestrated.
"""

import logging
import asyncio
from datetime import datetime, timezone
from typing import Optional

from fastmcp import FastMCP

# Import our modules
from . import sheets_connector
from . import analysis
from . import storage
from . import reporting
from . import risk_analysis
from . import insider_trading
from . import short_volume

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Create the MCP agent
mcp = FastMCP("Investment Portfolio Agent")


@mcp.tool()
def run_portfolio_analysis() -> str:
    """
    Manually trigger a portfolio analysis run.
    
    Returns:
        str: Analysis result message
    """
    try:
        return _run_weekly_analysis()
    except Exception as e:
        error_msg = f"Portfolio analysis failed: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_portfolio_status() -> str:
    """
    Get the current portfolio status from the latest snapshot.
    
    Returns:
        str: Current portfolio status
    """
    try:
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return "No portfolio snapshots available. Run analysis first."
        
        timestamp = latest_snapshot.get('timestamp', 'Unknown time')
        total_value = latest_snapshot.get('total_value_eur', 0.0)
        asset_count = len(latest_snapshot.get('assets', []))
        
        return f"""ðŸ“Š Latest Portfolio Status
        
**Last Updated:** {timestamp}
**Total Value:** â‚¬{total_value:,.2f}
**Number of Assets:** {asset_count}

Run portfolio analysis to generate a new snapshot and comparison report."""
        
    except Exception as e:
        error_msg = f"Failed to get portfolio status: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_portfolio_history_summary() -> str:
    """
    Get a summary of the portfolio history.
    
    Returns:
        str: Portfolio history summary
    """
    try:
        all_snapshots = storage.get_all_snapshots()
        
        if not all_snapshots:
            return "No portfolio history available."
        
        first_snapshot = all_snapshots[0]
        latest_snapshot = all_snapshots[-1]
        
        first_date = first_snapshot.get('timestamp', 'Unknown')
        latest_date = latest_snapshot.get('timestamp', 'Unknown')
        first_value = first_snapshot.get('total_value_eur', 0.0)
        latest_value = latest_snapshot.get('total_value_eur', 0.0)
        
        total_change = latest_value - first_value
        total_change_percent = (total_change / first_value * 100) if first_value > 0 else 0
        
        change_emoji = "ðŸ“ˆ" if total_change >= 0 else "ðŸ“‰"
        change_sign = "+" if total_change >= 0 else ""
        
        return f"""ðŸ“ˆ Portfolio History Summary

**Total Snapshots:** {len(all_snapshots)}
**First Snapshot:** {first_date}
**Latest Snapshot:** {latest_date}

**Performance Since Start:**
- Initial Value: â‚¬{first_value:,.2f}
- Current Value: â‚¬{latest_value:,.2f}
- Total Change: {change_emoji} {change_sign}â‚¬{total_change:,.2f} ({change_sign}{total_change_percent:.2f}%)"""
        
    except Exception as e:
        error_msg = f"Failed to get portfolio history: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_latest_positions() -> str:
    """
    Get all current portfolio positions organized by category.
    
    Fetches the latest portfolio snapshot and displays all positions
    grouped by asset category (Stocks, Bonds, ETFs, Pension, Cash) with
    detailed information including quantities, values, and gain/loss.
    
    Returns:
        str: Formatted list of all positions organized by category
    """
    try:
        logger.info("Fetching latest portfolio positions...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# ðŸ’¼ Current Portfolio Positions

No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Generated by Investment MCP Agent*"""
        
        organized_data = analysis.organize_positions_by_category(latest_snapshot)
        
        markdown_report = reporting.format_positions_markdown(organized_data)
        
        logger.info("Successfully retrieved latest positions")
        return markdown_report
        
    except Exception as e:
        error_msg = f"Failed to get latest positions: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ’¼ Current Portfolio Positions

## âŒ Error
{error_msg}

*Generated by Investment MCP Agent*"""


@mcp.tool()
def get_upcoming_events() -> str:
    """
     Get upcoming earnings reports for portfolio stocks.
     
     Returns upcoming earnings reports within the next 2 months, sorted chronologically.
     Events are fetched from Yahoo Finance API and matched against portfolio stocks
     using the ticker_mapping.json file.
    
    Returns:
        str: Formatted list of upcoming events or error message
    """
    try:
        from . import events_tracker
        
        logger.info("Fetching upcoming events for portfolio...")
        
        raw_data = sheets_connector.fetch_portfolio_data()
        normalized_data = sheets_connector.parse_and_normalize_data(raw_data)
        
        result = events_tracker.get_portfolio_upcoming_events(normalized_data)
        
        if not result.get("success", False):
            if result.get("unmapped_stocks"):
                error_lines = [result.get("error", "Error")]
                error_lines.extend(result.get("unmapped_stocks", []))
                error_lines.append("")
                error_lines.append(result.get("action", ""))
                return "\n".join(error_lines)
            else:
                return result.get("error", "Unknown error occurred")
        
        events = result.get("events", [])
        
        if not events:
            return """ðŸ“… Upcoming Earnings Reports

No upcoming earnings reports found within the next 2 months for your portfolio stocks.

**Note:** Ensure that:
1. All portfolio stocks are mapped in ticker_mapping.json
2. Your stocks have upcoming earnings announcements"""
        
        output_lines = ["ðŸ“… Upcoming Earnings Reports (Next 2 Months)", "", ""]
        
        for event in events:
            event_type = event.get("type", "")
            ticker = event.get("ticker", "")
            company = event.get("company_name", "")
            date = event.get("date", "")
            days_until = event.get("days_until", 0)
            
            output_lines.append(f"**{event_type}**")
            output_lines.append(f"- Ticker: {ticker}")
            output_lines.append(f"- Company: {company}")
            output_lines.append(f"- Date: {date} ({days_until} days)")
            
            if event_type == "Earnings Report":
                estimate = event.get("estimate")
                if estimate:
                    output_lines.append(f"- Estimate: {estimate}")
            
            output_lines.append("")
        
        output_lines.append(f"**Summary:**")
        output_lines.append(f"- Total Reports: {result.get('total_events', 0)}")
        output_lines.append(f"- Earnings Reports: {result.get('earnings_count', 0)}")
        output_lines.append(f"- Data Source: {result.get('provider', 'Unknown')}")
        output_lines.append(f"- Last Updated: {result.get('as_of', 'Unknown')}")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get upcoming events: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return error_msg


@mcp.tool()
def get_earnings_date(ticker: str) -> str:
    """
    Get the next earnings date for a specific stock ticker.
    
    Fetches the upcoming earnings report date for any stock ticker symbol
    using Yahoo Finance API. No API key required.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
    
    Returns:
        str: Formatted earnings date information or error message
    """
    try:
        from . import events_tracker
        
        logger.info(f"Fetching earnings date for {ticker}...")
        
        result = events_tracker.get_earnings_for_ticker(ticker)
        
        if not result.get("success", False):
            return f"""# ðŸ“… Earnings Date - {ticker}

## âŒ Error
{result.get('error', 'Unknown error occurred')}

*Data provided by Yahoo Finance*"""
        
        days_until = result.get("days_until", 0)
        report_date = result.get("report_date", "Unknown")
        company_name = result.get("company_name", ticker)
        estimate = result.get("estimate")
        
        output_lines = [
            f"# ðŸ“… Earnings Date - {ticker}",
            "",
            f"**Company:** {company_name}",
            f"**Report Date:** {report_date}",
            f"**Days Until:** {days_until} days",
            "",
        ]
        
        if estimate:
            output_lines.append(f"**Earnings Estimate:** ${estimate:.2f}")
            output_lines.append("")
        
        fiscal_period = result.get("fiscal_period")
        if fiscal_period:
            output_lines.append(f"**Fiscal Period:** {fiscal_period}")
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**Data Source:** {result.get('source', 'Unknown')}")
        output_lines.append(f"**Last Updated:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by Yahoo Finance*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get earnings date: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“… Earnings Date - {ticker}

## âŒ Error
{error_msg}

*Data provided by Yahoo Finance*"""


@mcp.tool()
def analyze_portfolio_risk() -> str:
    """
    Perform comprehensive risk analysis on the current portfolio.
    
    Calculates:
    - Portfolio beta (market sensitivity)
    - Value at Risk (VaR) at 95% and 99% confidence
    - Concentration risk score and HHI
    - Correlation matrix between holdings
    - Sector/geography exposure breakdown
    - Volatility by asset class
    - Downside risk metrics (Sortino, max drawdown, CVaR)
    
    This analysis fetches historical price data from Alpha Vantage API
    and may take several minutes to complete due to API rate limits.
    
    Returns:
        str: Formatted markdown risk analysis report
    """
    try:
        logger.info("Starting portfolio risk analysis...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# ðŸ“Š Portfolio Risk Analysis

## âŒ Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Risk analysis generated by Investment MCP Agent*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# ðŸ“Š Portfolio Risk Analysis

## âŒ Error
No assets found in portfolio snapshot.

*Risk analysis generated by Investment MCP Agent*"""
        
        logger.info(f"Analyzing risk for {len(portfolio_assets)} portfolio assets...")
        
        risk_data = risk_analysis.analyze_portfolio_risk(portfolio_assets)
        
        markdown_report = reporting.format_risk_report_markdown(risk_data)
        
        logger.info("Portfolio risk analysis completed successfully")
        return markdown_report
        
    except Exception as e:
        error_msg = f"Risk analysis failed: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Portfolio Risk Analysis

## âŒ Error
{error_msg}

Please check:
- Alpha Vantage API key is configured
- Ticker mappings are complete in ticker_mapping.json
- Portfolio has sufficient data

*Risk analysis generated by Investment MCP Agent*"""


@mcp.tool()
def get_insider_trades(ticker: str) -> str:
    """
    Get insider trading activity for a specific stock ticker.
    
    Fetches and analyzes insider trades (buys, sells, option exercises) for 
    the specified ticker over the last 90 days. Provides buy/sell statistics,
    sentiment analysis, and recent transaction details.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
    
    Returns:
        str: Formatted insider trading report with statistics and recent trades
    """
    try:
        logger.info(f"Fetching insider trades for {ticker}...")
        
        result = insider_trading.get_insider_trades_for_ticker(ticker)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            return f"""# ðŸ“Š Insider Trading - {ticker}

## âŒ Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        if result['total_trades'] == 0:
            return f"""# ðŸ“Š Insider Trading - {ticker}

No insider trading activity found in the last 90 days.

**Data URL:** {result.get('url', 'N/A')}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        stats = result['statistics']
        
        output_lines = [
            f"# ðŸ“Š Insider Trading - {ticker}",
            "",
            "## Summary (Last 90 Days)",
            "",
            f"**Total Transactions:** {result['total_trades']}",
            f"**Buy Transactions:** {stats['total_buys']}",
            f"**Sell Transactions:** {stats['total_sells']}",
            "",
            f"**Total Buy Value:** ${stats['buy_value_usd']:,.2f}",
            f"**Total Sell Value:** ${stats['sell_value_usd']:,.2f}",
            f"**Net Sentiment:** {stats['net_sentiment']}",
            "",
        ]
        
        if result['trades']:
            output_lines.append("## Recent Transactions")
            output_lines.append("")
            
            for trade in result['trades'][:10]:
                code = trade.get('code', 'Unknown')
                date = trade.get('transactionDate', trade.get('fileDate', 'Unknown'))
                insider = trade.get('name', 'Unknown')
                shares = trade.get('shares', 0)
                value = trade.get('value', 0)
                
                output_lines.append(f"**{date}** - {insider}")
                output_lines.append(f"- Type: {code}")
                output_lines.append(f"- Shares: {shares:,.0f}")
                if value:
                    output_lines.append(f"- Value: ${value:,.2f}")
                output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**Data URL:** {result.get('url', 'N/A')}")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get insider trades: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Insider Trading - {ticker}

## âŒ Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_portfolio_insider_trades() -> str:
    """
    Get insider trading activity for all stocks in the portfolio.
    
    Analyzes insider trading for all portfolio stocks over the last 90 days.
    Shows which stocks have significant insider buying or selling activity,
    organized by sentiment (Bullish/Neutral/Bearish).
    
    Note: Only analyzes stocks (excludes bonds, ETFs, pension, cash positions).
    Uses ticker_mapping.json to map portfolio stock names to ticker symbols.
    
    Returns:
        str: Formatted insider trading summary for entire portfolio
    """
    try:
        logger.info("Fetching insider trades for portfolio...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# ðŸ“Š Portfolio Insider Trading

## âŒ Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# ðŸ“Š Portfolio Insider Trading

## âŒ Error
No assets found in portfolio snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        result = insider_trading.get_portfolio_insider_trades(portfolio_assets)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            
            if result.get('unmapped_stocks'):
                unmapped_list = "\n".join([f"- {stock}" for stock in result['unmapped_stocks']])
                return f"""# ðŸ“Š Portfolio Insider Trading

## âŒ Error
{error_msg}

**Unmapped stocks:**
{unmapped_list}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
            
            return f"""# ðŸ“Š Portfolio Insider Trading

## âŒ Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        output_lines = [
            "# ðŸ“Š Portfolio Insider Trading Analysis",
            "",
            "## Summary (Last 90 Days)",
            "",
            f"**Stocks Analyzed:** {result.get('stocks_analyzed', 0)}",
            f"**Stocks with Activity:** {result.get('stocks_with_activity', 0)}",
            f"**Total Transactions:** {result.get('total_transactions', 0)}",
            "",
        ]
        
        by_sentiment = result.get('by_sentiment', {})
        
        for sentiment in ['Bullish', 'Neutral', 'Bearish']:
            stocks = by_sentiment.get(sentiment, [])
            if stocks:
                sentiment_emoji = "ðŸŸ¢" if sentiment == "Bullish" else "ðŸŸ¡" if sentiment == "Neutral" else "ðŸ”´"
                output_lines.append(f"## {sentiment_emoji} {sentiment} Sentiment")
                output_lines.append("")
                
                for stock_data in stocks:
                    ticker = stock_data.get('ticker', 'Unknown')
                    stats = stock_data.get('statistics', {})
                    
                    output_lines.append(f"### {ticker}")
                    output_lines.append(f"- Transactions: {stock_data.get('total_trades', 0)}")
                    output_lines.append(f"- Buys: {stats.get('total_buys', 0)} (${stats.get('buy_value_usd', 0):,.2f})")
                    output_lines.append(f"- Sells: {stats.get('total_sells', 0)} (${stats.get('sell_value_usd', 0):,.2f})")
                    output_lines.append("")
        
        stocks_no_activity = result.get('stocks_no_activity', [])
        if stocks_no_activity:
            output_lines.append("## No Recent Activity")
            output_lines.append("")
            output_lines.append(", ".join(stocks_no_activity))
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get portfolio insider trades: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Portfolio Insider Trading

## âŒ Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_short_volume(ticker: str, days: int = 30) -> str:
    """
    Get short volume data for a specific stock ticker.
    
    Shows daily short selling activity over the specified period,
    including short volume ratio, trends, and risk assessment based
    on short selling patterns.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
        days: Number of days to look back (default: 30)
    
    Returns:
        str: Formatted short volume report with metrics and analysis
    """
    try:
        logger.info(f"Fetching short volume for {ticker}...")
        
        result = short_volume.get_short_volume_for_ticker(ticker, days)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            return f"""# ðŸ“Š Short Volume Analysis - {ticker}

## âŒ Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        if result.get('metrics', {}).get('data_points', 0) == 0:
            return f"""# ðŸ“Š Short Volume Analysis - {ticker}

No short volume data available for this ticker.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        metrics = result['metrics']
        
        output_lines = [
            f"# ðŸ“Š Short Volume Analysis - {ticker}",
            "",
            f"## Current Metrics ({metrics['data_points']} days)",
            "",
            f"**Average Short Ratio:** {metrics['avg_short_ratio']:.2f}%",
            f"**Latest Short Ratio:** {metrics['latest_short_ratio']:.2f}% ({metrics['latest_date']})",
            f"**7-Day Average:** {metrics['avg_7day']:.2f}%",
            f"**30-Day Average:** {metrics['avg_30day']:.2f}%",
            "",
            f"**Trend:** {metrics['trend']}",
            "",
        ]
        
        risk = result.get('risk_analysis', {})
        if risk:
            output_lines.append("## Risk Assessment")
            output_lines.append("")
            output_lines.append(f"**Risk Level:** {risk['risk_emoji']} {risk['risk_level']}")
            output_lines.append(f"**Description:** {risk['description']}")
            if risk.get('factors'):
                output_lines.append("")
                output_lines.append("**Factors:**")
                for factor in risk['factors']:
                    output_lines.append(f"- {factor}")
            output_lines.append("")
        
        data_records = result.get('data', [])
        if data_records:
            sorted_records = sorted(data_records, key=lambda x: x.get('marketDate', ''), reverse=True)
            output_lines.append("## Recent Activity (Last 5 Days)")
            output_lines.append("")
            
            for record in sorted_records[:5]:
                date = record.get('marketDate', 'Unknown')
                short_vol = record.get('shortVolume', 0)
                total_vol = record.get('totalVolume', 0)
                ratio = record.get('shortVolumeRatio', 0) * 100
                
                output_lines.append(f"**{date}**")
                output_lines.append(f"- Short Volume: {short_vol:,} shares")
                output_lines.append(f"- Total Volume: {total_vol:,} shares")
                output_lines.append(f"- Short Ratio: {ratio:.2f}%")
                output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get short volume: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Short Volume Analysis - {ticker}

## âŒ Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_portfolio_short_analysis() -> str:
    """
    Analyze short selling activity across all portfolio stocks.
    
    Identifies stocks with high short volume ratios, unusual short
    selling patterns, and potential risks. Organizes results by risk
    level (High/Medium/Low) based on short volume patterns.
    
    Note: Only analyzes stocks (excludes bonds, ETFs, pension, cash).
    Uses ticker_mapping.json to map portfolio stock names to tickers.
    
    Returns:
        str: Formatted portfolio-wide short volume analysis
    """
    try:
        logger.info("Fetching short volume analysis for portfolio...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
No assets found in portfolio snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        result = short_volume.get_portfolio_short_analysis(portfolio_assets)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            
            if result.get('unmapped_stocks'):
                unmapped_list = "\n".join([f"- {stock}" for stock in result['unmapped_stocks']])
                return f"""# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
{error_msg}

**Unmapped stocks:**
{unmapped_list}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
            
            return f"""# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        output_lines = [
            "# ðŸ“Š Portfolio Short Volume Analysis",
            "",
            "## Summary",
            "",
            f"**Stocks Analyzed:** {result.get('stocks_analyzed', 0)}",
            f"**Stocks with Data:** {result.get('stocks_with_data', 0)}",
            f"**Average Short Ratio:** {result.get('avg_short_ratio', 0):.2f}%",
            "",
            f"**High Risk Stocks:** {result.get('high_risk_count', 0)}",
            f"**Medium Risk Stocks:** {result.get('medium_risk_count', 0)}",
            f"**Low Risk Stocks:** {result.get('low_risk_count', 0)}",
            "",
        ]
        
        by_risk = result.get('by_risk', {})
        
        if by_risk.get('high'):
            output_lines.append("## ðŸ”´ High Risk (Elevated Short Activity)")
            output_lines.append("")
            
            for stock_data in by_risk['high']:
                ticker = stock_data.get('ticker', 'Unknown')
                metrics = stock_data.get('metrics', {})
                risk = stock_data.get('risk_analysis', {})
                
                output_lines.append(f"### {ticker}")
                output_lines.append(f"- Average Short Ratio: {metrics.get('avg_short_ratio', 0):.2f}%")
                output_lines.append(f"- Trend: {metrics.get('trend', 'Unknown')}")
                output_lines.append(f"- Risk: {risk.get('description', 'Unknown')}")
                if risk.get('factors'):
                    for factor in risk['factors']:
                        output_lines.append(f"  - {factor}")
                output_lines.append("")
        
        if by_risk.get('medium'):
            output_lines.append("## ðŸŸ¡ Medium Risk (Moderate Short Activity)")
            output_lines.append("")
            
            for stock_data in by_risk['medium']:
                ticker = stock_data.get('ticker', 'Unknown')
                metrics = stock_data.get('metrics', {})
                
                output_lines.append(f"### {ticker}")
                output_lines.append(f"- Average Short Ratio: {metrics.get('avg_short_ratio', 0):.2f}%")
                output_lines.append(f"- Trend: {metrics.get('trend', 'Unknown')}")
                output_lines.append("")
        
        if by_risk.get('low'):
            output_lines.append("## ðŸŸ¢ Low Risk (Normal Short Activity)")
            output_lines.append("")
            low_tickers = [s.get('ticker', 'Unknown') for s in by_risk['low']]
            output_lines.append(", ".join(low_tickers[:10]))
            if len(low_tickers) > 10:
                output_lines.append(f"... and {len(low_tickers) - 10} more")
            output_lines.append("")
        
        stocks_no_data = result.get('stocks_no_data', [])
        if stocks_no_data:
            output_lines.append("## No Data Available")
            output_lines.append("")
            output_lines.append(", ".join(stocks_no_data))
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get portfolio short analysis: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def generate_portfolio_dashboard(time_period: str = "all") -> str:
    """
    Generate interactive HTML dashboard with portfolio visualizations.
    
    Creates a comprehensive dashboard showing portfolio performance, allocation,
    individual asset trends, benchmark comparisons, and risk metrics over time.
    
    Args:
        time_period: One of "7d", "30d", "90d", "1y", "all" (default: "all")
    
    Returns:
        str: Path to generated HTML file with instructions to open
    """
    try:
        from . import visualization
        
        logger.info(f"Generating portfolio dashboard for period: {time_period}")
        
        result = visualization.generate_portfolio_dashboard(time_period)
        
        if not result.get("success"):
            return f"""# ðŸ“Š Portfolio Dashboard Generation Failed
            
## âŒ Error
{result.get('error', 'Unknown error occurred')}

*Dashboard generation by Investment MCP Agent*"""
        
        file_path = result.get("file_path")
        file_url = result.get("file_url")
        snapshot_count = result.get("snapshot_count", 0)
        date_range = result.get("date_range", {})
        
        output_lines = [
            "# âœ… Portfolio Dashboard Generated Successfully!",
            "",
            "## ðŸ“Š Dashboard Location",
            f"**File Path:** `{file_path}`",
            f"**URL:** {file_url}",
            "",
            "### To Open:",
            "- Click the URL above (in supported clients)",
            f"- Or run: `open {file_path}`",
            "",
            "## ðŸ“ˆ Dashboard Includes:",
            "- **Portfolio Value Trend** (vs S&P 500 & All-World Index)",
            "- **Category Allocation Over Time** (stacked areas)",
            "- **Individual Asset Performance** (top 10 by default, all selectable)",
            "- **Top Holdings Evolution** (position changes)",
            "- **Gain/Loss Analysis** (current positions)",
            "- **Transaction Timeline** (buy/sell activity)",
            "- **Currency Exposure Breakdown**",
            "- **Risk Metrics Dashboard** (Sharpe, Drawdown, Returns, Contribution)",
            "",
            "## ðŸ“… Data Range:",
            f"- **Period:** {time_period}",
            f"- **Start Date:** {date_range.get('start', 'N/A')}",
            f"- **End Date:** {date_range.get('end', 'N/A')}",
            f"- **Snapshots:** {snapshot_count}",
            "",
            "## ðŸŽ›ï¸ Interactive Features:",
            "- **Time Period Selector:** Change date range with dropdown",
            "- **Asset Selector:** Multi-select which assets to display",
            "- **Zoom & Pan:** Interactive chart controls",
            "- **Hover Details:** Detailed tooltips on all data points",
            "- **Toggle Series:** Click legend items to show/hide",
            "",
            "---",
            f"*Generated at: {result.get('generated_at', 'Unknown')}*",
            "*Dashboard by Investment MCP Agent*"
        ]
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to generate dashboard: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Portfolio Dashboard Generation Failed

## âŒ Error
{error_msg}

*Dashboard generation by Investment MCP Agent*"""


@mcp.tool()
def get_storage_status() -> str:
    """
    Get the current storage backend status.
    
    Shows whether GCP is available, sync status, and any pending uploads.
    Useful for debugging storage issues or verifying cloud sync.
    
    Returns:
        str: Storage status information
    """
    try:
        logger.info("Fetching storage backend status...")
        
        status = storage.get_storage_status()
        
        output_lines = ["# ðŸ’¾ Storage Backend Status", ""]
        
        backend_type = status.get("backend_type", "Unknown")
        available = status.get("available", False)
        
        output_lines.append(f"**Backend Type:** {backend_type}")
        output_lines.append(f"**Available:** {'âœ… Yes' if available else 'âŒ No'}")
        output_lines.append("")
        
        # Hybrid storage details
        if "primary_available" in status:
            output_lines.append("## Hybrid Storage Details")
            output_lines.append("")
            
            primary_avail = status.get('primary_available', False)
            fallback_avail = status.get('fallback_available', False)
            pending_syncs = status.get('pending_syncs', 0)
            fully_synced = status.get('fully_synced', False)
            
            output_lines.append(f"**Primary (GCP):** {'âœ… Available' if primary_avail else 'âŒ Unavailable'}")
            output_lines.append(f"**Fallback (Local):** {'âœ… Available' if fallback_avail else 'âŒ Unavailable'}")
            output_lines.append(f"**Pending Syncs:** {pending_syncs}")
            output_lines.append(f"**Fully Synced:** {'âœ… Yes' if fully_synced else 'âš ï¸ No'}")
            output_lines.append("")
            
            if pending_syncs > 0:
                output_lines.append("âš ï¸ **Warning:** Some snapshots are queued for GCP upload")
                output_lines.append("They will be automatically synced when GCP becomes available")
                output_lines.append("")
            
            if fully_synced and primary_avail:
                output_lines.append("âœ… **All Good:** Portfolio data is synced to cloud storage")
                output_lines.append("")
        
        # Error handling
        if "error" in status:
            output_lines.append("## âŒ Error")
            output_lines.append("")
            output_lines.append(f"Failed to get storage status: {status['error']}")
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append("")
        output_lines.append("**Storage Location:**")
        output_lines.append("- Primary: `gs://investment_snapshots/portfolio_history.json`")
        output_lines.append("- Fallback: `./portfolio_history.json`")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get storage status: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ’¾ Storage Backend Status

## âŒ Error
{error_msg}

*Generated by Investment MCP Agent*"""


def _run_weekly_analysis() -> str:
    """
    Core function that performs the weekly portfolio analysis workflow.
    NOW INCLUDES: Automatic dashboard generation.
    
    Returns:
        str: Result message
    """
    try:
        logger.info("Starting weekly portfolio analysis...")
        
        # Get the previous snapshot
        previous_snapshot = storage.get_latest_snapshot()
        
        # Fetch and normalize current portfolio data
        logger.info("Fetching portfolio data from Google Sheets...")
        raw_data = sheets_connector.fetch_portfolio_data()
        normalized_data = sheets_connector.parse_and_normalize_data(raw_data)
        
        # Create new snapshot
        logger.info("Creating portfolio snapshot...")
        current_snapshot = analysis.create_portfolio_snapshot(normalized_data)
        
        # Save the snapshot immediately
        storage.save_snapshot(current_snapshot)
        logger.info("Snapshot saved successfully")
        
        # Generate dashboard after snapshot is saved
        dashboard_link = ""
        try:
            from . import visualization
            logger.info("Generating portfolio dashboard...")
            dashboard_result = visualization.generate_portfolio_dashboard(
                time_period="all",
                force_regenerate=True
            )
            if dashboard_result.get("success"):
                dashboard_path = dashboard_result.get("file_path")
                dashboard_url = dashboard_result.get("file_url")
                logger.info(f"Dashboard generated: {dashboard_path}")
                dashboard_link = f"\n\n---\n\nðŸ“Š **Interactive Dashboard:** {dashboard_url}\n\nOpen in browser to explore interactive charts and metrics.\n"
            else:
                logger.warning(f"Dashboard generation failed: {dashboard_result.get('error')}")
        except Exception as e:
            logger.error(f"Failed to generate dashboard: {e}", exc_info=False)
            # Don't fail the entire analysis if dashboard generation fails
        
        # If we have a previous snapshot, perform comparison
        if previous_snapshot:
            logger.info("Performing week-over-week comparison...")
            report_data = analysis.compare_snapshots(current_snapshot, previous_snapshot)
            
            # Generate markdown report
            current_total_value = current_snapshot.get('total_value_eur', 0.0)
            markdown_report = reporting.format_report_markdown(report_data, current_total_value, current_snapshot)
            
            # Add dashboard link to report
            markdown_report += dashboard_link
            
            logger.info("Weekly analysis completed successfully")
            return markdown_report
        else:
            # First run
            current_total_value = current_snapshot.get('total_value_eur', 0.0)
            first_run_message = f"""# ðŸ“Š Portfolio Tracking Initialized

**Initial Portfolio Value:** â‚¬{current_total_value:,.2f}
**Assets Tracked:** {len(normalized_data)}
**Timestamp:** {current_snapshot.get('timestamp', 'Unknown')}

This is the first snapshot of your portfolio. Weekly comparison reports will be available starting next week.
"""
            
            # Add dashboard note
            if dashboard_link:
                first_run_message += dashboard_link
            else:
                first_run_message += "\n\nðŸ“Š **Dashboard:** Not enough data yet (need 2+ snapshots)\n"
            
            first_run_message += "\n---\n*Report generated automatically by Investment MCP Agent*"
            
            logger.info("First portfolio snapshot created successfully")
            return first_run_message
            
    except Exception as e:
        error_msg = f"Weekly analysis failed: {str(e)}"
        logger.error(error_msg, exc_info=True)
        raise


if __name__ == "__main__":
    # For testing purposes, you can run the analysis directly
    try:
        result = _run_weekly_analysis()
        print(result)
    except Exception as e:
        print(f"Error: {e}")