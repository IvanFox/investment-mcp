"""
Main Entry Point for Investment MCP Agent

This is the main entry point where the fastmcp agent is defined and 
the scheduled task is orchestrated.
"""

import logging
import asyncio
from datetime import datetime, timezone
from typing import Optional

from fastmcp import FastMCP

# Import our modules
from . import sheets_connector
from . import analysis
from . import storage
from . import reporting
from . import risk_analysis
from . import insider_trading
from . import short_volume

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Create the MCP agent
mcp = FastMCP("Investment Portfolio Agent")


@mcp.tool()
def run_portfolio_analysis() -> str:
    """
    Manually trigger a portfolio analysis run.
    
    Returns:
        str: Analysis result message
    """
    try:
        return _run_weekly_analysis()
    except Exception as e:
        error_msg = f"Portfolio analysis failed: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_portfolio_status() -> str:
    """
    Get the current portfolio status from the latest snapshot.
    
    Returns:
        str: Current portfolio status
    """
    try:
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return "No portfolio snapshots available. Run analysis first."
        
        timestamp = latest_snapshot.get('timestamp', 'Unknown time')
        total_value = latest_snapshot.get('total_value_eur', 0.0)
        asset_count = len(latest_snapshot.get('assets', []))
        
        return f"""ðŸ“Š Latest Portfolio Status
        
**Last Updated:** {timestamp}
**Total Value:** â‚¬{total_value:,.2f}
**Number of Assets:** {asset_count}

Run portfolio analysis to generate a new snapshot and comparison report."""
        
    except Exception as e:
        error_msg = f"Failed to get portfolio status: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_portfolio_history_summary() -> str:
    """
    Get a summary of the portfolio history.
    
    Returns:
        str: Portfolio history summary
    """
    try:
        all_snapshots = storage.get_all_snapshots()
        
        if not all_snapshots:
            return "No portfolio history available."
        
        first_snapshot = all_snapshots[0]
        latest_snapshot = all_snapshots[-1]
        
        first_date = first_snapshot.get('timestamp', 'Unknown')
        latest_date = latest_snapshot.get('timestamp', 'Unknown')
        first_value = first_snapshot.get('total_value_eur', 0.0)
        latest_value = latest_snapshot.get('total_value_eur', 0.0)
        
        total_change = latest_value - first_value
        total_change_percent = (total_change / first_value * 100) if first_value > 0 else 0
        
        change_emoji = "ðŸ“ˆ" if total_change >= 0 else "ðŸ“‰"
        change_sign = "+" if total_change >= 0 else ""
        
        return f"""ðŸ“ˆ Portfolio History Summary

**Total Snapshots:** {len(all_snapshots)}
**First Snapshot:** {first_date}
**Latest Snapshot:** {latest_date}

**Performance Since Start:**
- Initial Value: â‚¬{first_value:,.2f}
- Current Value: â‚¬{latest_value:,.2f}
- Total Change: {change_emoji} {change_sign}â‚¬{total_change:,.2f} ({change_sign}{total_change_percent:.2f}%)"""
        
    except Exception as e:
        error_msg = f"Failed to get portfolio history: {str(e)}"
        logger.error(error_msg)
        return error_msg


@mcp.tool()
def get_latest_positions() -> str:
    """
    Get all current portfolio positions organized by category.
    
    Fetches the latest portfolio snapshot and displays all positions
    grouped by asset category (Stocks, Bonds, ETFs, Pension, Cash) with
    detailed information including quantities, values, and gain/loss.
    
    Returns:
        str: Formatted list of all positions organized by category
    """
    try:
        logger.info("Fetching latest portfolio positions...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# ðŸ’¼ Current Portfolio Positions

No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Generated by Investment MCP Agent*"""
        
        organized_data = analysis.organize_positions_by_category(latest_snapshot)
        
        markdown_report = reporting.format_positions_markdown(organized_data)
        
        logger.info("Successfully retrieved latest positions")
        return markdown_report
        
    except Exception as e:
        error_msg = f"Failed to get latest positions: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ’¼ Current Portfolio Positions

## âŒ Error
{error_msg}

*Generated by Investment MCP Agent*"""


@mcp.tool()
def get_upcoming_events() -> str:
    """
     Get upcoming earnings reports for portfolio stocks.
     
     Returns upcoming earnings reports within the next 2 months, sorted chronologically.
     Events are fetched from Yahoo Finance API and matched against portfolio stocks
     using the ticker_mapping.json file.
    
    Returns:
        str: Formatted list of upcoming events or error message
    """
    try:
        from . import events_tracker
        
        logger.info("Fetching upcoming events for portfolio...")
        
        raw_data = sheets_connector.fetch_portfolio_data()
        normalized_data = sheets_connector.parse_and_normalize_data(raw_data)
        
        result = events_tracker.get_portfolio_upcoming_events(normalized_data)
        
        if not result.get("success", False):
            if result.get("unmapped_stocks"):
                error_lines = [result.get("error", "Error")]
                error_lines.extend(result.get("unmapped_stocks", []))
                error_lines.append("")
                error_lines.append(result.get("action", ""))
                return "\n".join(error_lines)
            else:
                return result.get("error", "Unknown error occurred")
        
        events = result.get("events", [])
        
        if not events:
            return """ðŸ“… Upcoming Earnings Reports

No upcoming earnings reports found within the next 2 months for your portfolio stocks.

**Note:** Ensure that:
1. All portfolio stocks are mapped in ticker_mapping.json
2. Your stocks have upcoming earnings announcements"""
        
        output_lines = ["ðŸ“… Upcoming Earnings Reports (Next 2 Months)", "", ""]
        
        for event in events:
            event_type = event.get("type", "")
            ticker = event.get("ticker", "")
            company = event.get("company_name", "")
            date = event.get("date", "")
            days_until = event.get("days_until", 0)
            
            output_lines.append(f"**{event_type}**")
            output_lines.append(f"- Ticker: {ticker}")
            output_lines.append(f"- Company: {company}")
            output_lines.append(f"- Date: {date} ({days_until} days)")
            
            if event_type == "Earnings Report":
                estimate = event.get("estimate")
                if estimate:
                    output_lines.append(f"- Estimate: {estimate}")
            
            output_lines.append("")
        
        output_lines.append(f"**Summary:**")
        output_lines.append(f"- Total Reports: {result.get('total_events', 0)}")
        output_lines.append(f"- Earnings Reports: {result.get('earnings_count', 0)}")
        output_lines.append(f"- Data Source: {result.get('provider', 'Unknown')}")
        output_lines.append(f"- Last Updated: {result.get('as_of', 'Unknown')}")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get upcoming events: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return error_msg


@mcp.tool()
def get_earnings_date(ticker: str) -> str:
    """
    Get the next earnings date for a specific stock ticker.
    
    Fetches the upcoming earnings report date for any stock ticker symbol
    using Yahoo Finance API. No API key required.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
    
    Returns:
        str: Formatted earnings date information or error message
    """
    try:
        from . import events_tracker
        
        logger.info(f"Fetching earnings date for {ticker}...")
        
        result = events_tracker.get_earnings_for_ticker(ticker)
        
        if not result.get("success", False):
            return f"""# ðŸ“… Earnings Date - {ticker}

## âŒ Error
{result.get('error', 'Unknown error occurred')}

*Data provided by Yahoo Finance*"""
        
        days_until = result.get("days_until", 0)
        report_date = result.get("report_date", "Unknown")
        company_name = result.get("company_name", ticker)
        estimate = result.get("estimate")
        
        output_lines = [
            f"# ðŸ“… Earnings Date - {ticker}",
            "",
            f"**Company:** {company_name}",
            f"**Report Date:** {report_date}",
            f"**Days Until:** {days_until} days",
            "",
        ]
        
        if estimate:
            output_lines.append(f"**Earnings Estimate:** ${estimate:.2f}")
            output_lines.append("")
        
        fiscal_period = result.get("fiscal_period")
        if fiscal_period:
            output_lines.append(f"**Fiscal Period:** {fiscal_period}")
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**Data Source:** {result.get('source', 'Unknown')}")
        output_lines.append(f"**Last Updated:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by Yahoo Finance*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get earnings date: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“… Earnings Date - {ticker}

## âŒ Error
{error_msg}

*Data provided by Yahoo Finance*"""


@mcp.tool()
def analyze_portfolio_risk() -> str:
    """
    Perform comprehensive risk analysis on the current portfolio.
    
    Calculates:
    - Portfolio beta (market sensitivity)
    - Value at Risk (VaR) at 95% and 99% confidence
    - Concentration risk score and HHI
    - Correlation matrix between holdings
    - Sector/geography exposure breakdown
    - Volatility by asset class
    - Downside risk metrics (Sortino, max drawdown, CVaR)
    
    This analysis fetches historical price data from Alpha Vantage API
    and may take several minutes to complete due to API rate limits.
    
    Returns:
        str: Formatted markdown risk analysis report
    """
    try:
        logger.info("Starting portfolio risk analysis...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# ðŸ“Š Portfolio Risk Analysis

## âŒ Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Risk analysis generated by Investment MCP Agent*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# ðŸ“Š Portfolio Risk Analysis

## âŒ Error
No assets found in portfolio snapshot.

*Risk analysis generated by Investment MCP Agent*"""
        
        logger.info(f"Analyzing risk for {len(portfolio_assets)} portfolio assets...")
        
        risk_data = risk_analysis.analyze_portfolio_risk(portfolio_assets)
        
        markdown_report = reporting.format_risk_report_markdown(risk_data)
        
        logger.info("Portfolio risk analysis completed successfully")
        return markdown_report
        
    except Exception as e:
        error_msg = f"Risk analysis failed: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Portfolio Risk Analysis

## âŒ Error
{error_msg}

Please check:
- Alpha Vantage API key is configured
- Ticker mappings are complete in ticker_mapping.json
- Portfolio has sufficient data

*Risk analysis generated by Investment MCP Agent*"""


@mcp.tool()
def get_insider_trades(ticker: str) -> str:
    """
    Get insider trading activity for a specific stock ticker.
    
    Fetches and analyzes insider trades (buys, sells, option exercises) for 
    the specified ticker over the last 90 days. Provides buy/sell statistics,
    sentiment analysis, and recent transaction details.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
    
    Returns:
        str: Formatted insider trading report with statistics and recent trades
    """
    try:
        logger.info(f"Fetching insider trades for {ticker}...")
        
        result = insider_trading.get_insider_trades_for_ticker(ticker)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            return f"""# ðŸ“Š Insider Trading - {ticker}

## âŒ Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        if result['total_trades'] == 0:
            return f"""# ðŸ“Š Insider Trading - {ticker}

No insider trading activity found in the last 90 days.

**Data URL:** {result.get('url', 'N/A')}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        stats = result['statistics']
        
        output_lines = [
            f"# ðŸ“Š Insider Trading - {ticker}",
            "",
            "## Summary (Last 90 Days)",
            "",
            f"**Total Transactions:** {result['total_trades']}",
            f"**Buy Transactions:** {stats['total_buys']}",
            f"**Sell Transactions:** {stats['total_sells']}",
            "",
            f"**Total Buy Value:** ${stats['buy_value_usd']:,.2f}",
            f"**Total Sell Value:** ${stats['sell_value_usd']:,.2f}",
            f"**Net Sentiment:** {stats['net_sentiment']}",
            "",
        ]
        
        if result['trades']:
            output_lines.append("## Recent Transactions")
            output_lines.append("")
            
            for trade in result['trades'][:10]:
                code = trade.get('code', 'Unknown')
                date = trade.get('transactionDate', trade.get('fileDate', 'Unknown'))
                insider = trade.get('name', 'Unknown')
                shares = trade.get('shares', 0)
                value = trade.get('value', 0)
                
                output_lines.append(f"**{date}** - {insider}")
                output_lines.append(f"- Type: {code}")
                output_lines.append(f"- Shares: {shares:,.0f}")
                if value:
                    output_lines.append(f"- Value: ${value:,.2f}")
                output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**Data URL:** {result.get('url', 'N/A')}")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get insider trades: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Insider Trading - {ticker}

## âŒ Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_portfolio_insider_trades() -> str:
    """
    Get insider trading activity for all stocks in the portfolio.
    
    Analyzes insider trading for all portfolio stocks over the last 90 days.
    Shows which stocks have significant insider buying or selling activity,
    organized by sentiment (Bullish/Neutral/Bearish).
    
    Note: Only analyzes stocks (excludes bonds, ETFs, pension, cash positions).
    Uses ticker_mapping.json to map portfolio stock names to ticker symbols.
    
    Returns:
        str: Formatted insider trading summary for entire portfolio
    """
    try:
        logger.info("Fetching insider trades for portfolio...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# ðŸ“Š Portfolio Insider Trading

## âŒ Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# ðŸ“Š Portfolio Insider Trading

## âŒ Error
No assets found in portfolio snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        result = insider_trading.get_portfolio_insider_trades(portfolio_assets)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            
            if result.get('unmapped_stocks'):
                unmapped_list = "\n".join([f"- {stock}" for stock in result['unmapped_stocks']])
                return f"""# ðŸ“Š Portfolio Insider Trading

## âŒ Error
{error_msg}

**Unmapped stocks:**
{unmapped_list}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
            
            return f"""# ðŸ“Š Portfolio Insider Trading

## âŒ Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        output_lines = [
            "# ðŸ“Š Portfolio Insider Trading Analysis",
            "",
            "## Summary (Last 90 Days)",
            "",
            f"**Stocks Analyzed:** {result.get('stocks_analyzed', 0)}",
            f"**Stocks with Activity:** {result.get('stocks_with_activity', 0)}",
            f"**Total Transactions:** {result.get('total_transactions', 0)}",
            "",
        ]
        
        by_sentiment = result.get('by_sentiment', {})
        
        for sentiment in ['Bullish', 'Neutral', 'Bearish']:
            stocks = by_sentiment.get(sentiment, [])
            if stocks:
                sentiment_emoji = "ðŸŸ¢" if sentiment == "Bullish" else "ðŸŸ¡" if sentiment == "Neutral" else "ðŸ”´"
                output_lines.append(f"## {sentiment_emoji} {sentiment} Sentiment")
                output_lines.append("")
                
                for stock_data in stocks:
                    ticker = stock_data.get('ticker', 'Unknown')
                    stats = stock_data.get('statistics', {})
                    
                    output_lines.append(f"### {ticker}")
                    output_lines.append(f"- Transactions: {stock_data.get('total_trades', 0)}")
                    output_lines.append(f"- Buys: {stats.get('total_buys', 0)} (${stats.get('buy_value_usd', 0):,.2f})")
                    output_lines.append(f"- Sells: {stats.get('total_sells', 0)} (${stats.get('sell_value_usd', 0):,.2f})")
                    output_lines.append("")
        
        stocks_no_activity = result.get('stocks_no_activity', [])
        if stocks_no_activity:
            output_lines.append("## No Recent Activity")
            output_lines.append("")
            output_lines.append(", ".join(stocks_no_activity))
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get portfolio insider trades: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Portfolio Insider Trading

## âŒ Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_short_volume(ticker: str, days: int = 30) -> str:
    """
    Get short volume data for a specific stock ticker.
    
    Shows daily short selling activity over the specified period,
    including short volume ratio, trends, and risk assessment based
    on short selling patterns.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "MSFT", "WISE.L")
        days: Number of days to look back (default: 30)
    
    Returns:
        str: Formatted short volume report with metrics and analysis
    """
    try:
        logger.info(f"Fetching short volume for {ticker}...")
        
        result = short_volume.get_short_volume_for_ticker(ticker, days)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            return f"""# ðŸ“Š Short Volume Analysis - {ticker}

## âŒ Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        if result.get('metrics', {}).get('data_points', 0) == 0:
            return f"""# ðŸ“Š Short Volume Analysis - {ticker}

No short volume data available for this ticker.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        metrics = result['metrics']
        
        output_lines = [
            f"# ðŸ“Š Short Volume Analysis - {ticker}",
            "",
            f"## Current Metrics ({metrics['data_points']} days)",
            "",
            f"**Average Short Ratio:** {metrics['avg_short_ratio']:.2f}%",
            f"**Latest Short Ratio:** {metrics['latest_short_ratio']:.2f}% ({metrics['latest_date']})",
            f"**7-Day Average:** {metrics['avg_7day']:.2f}%",
            f"**30-Day Average:** {metrics['avg_30day']:.2f}%",
            "",
            f"**Trend:** {metrics['trend']}",
            "",
        ]
        
        risk = result.get('risk_analysis', {})
        if risk:
            output_lines.append("## Risk Assessment")
            output_lines.append("")
            output_lines.append(f"**Risk Level:** {risk['risk_emoji']} {risk['risk_level']}")
            output_lines.append(f"**Description:** {risk['description']}")
            if risk.get('factors'):
                output_lines.append("")
                output_lines.append("**Factors:**")
                for factor in risk['factors']:
                    output_lines.append(f"- {factor}")
            output_lines.append("")
        
        data_records = result.get('data', [])
        if data_records:
            sorted_records = sorted(data_records, key=lambda x: x.get('marketDate', ''), reverse=True)
            output_lines.append("## Recent Activity (Last 5 Days)")
            output_lines.append("")
            
            for record in sorted_records[:5]:
                date = record.get('marketDate', 'Unknown')
                short_vol = record.get('shortVolume', 0)
                total_vol = record.get('totalVolume', 0)
                ratio = record.get('shortVolumeRatio', 0) * 100
                
                output_lines.append(f"**{date}**")
                output_lines.append(f"- Short Volume: {short_vol:,} shares")
                output_lines.append(f"- Total Volume: {total_vol:,} shares")
                output_lines.append(f"- Short Ratio: {ratio:.2f}%")
                output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get short volume: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Short Volume Analysis - {ticker}

## âŒ Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


@mcp.tool()
def get_portfolio_short_analysis() -> str:
    """
    Analyze short selling activity across all portfolio stocks.
    
    Identifies stocks with high short volume ratios, unusual short
    selling patterns, and potential risks. Organizes results by risk
    level (High/Medium/Low) based on short volume patterns.
    
    Note: Only analyzes stocks (excludes bonds, ETFs, pension, cash).
    Uses ticker_mapping.json to map portfolio stock names to tickers.
    
    Returns:
        str: Formatted portfolio-wide short volume analysis
    """
    try:
        logger.info("Fetching short volume analysis for portfolio...")
        
        latest_snapshot = storage.get_latest_snapshot()
        
        if not latest_snapshot:
            return """# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
No portfolio snapshots available. Please run `run_portfolio_analysis()` first to create a snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        portfolio_assets = latest_snapshot.get('assets', [])
        
        if not portfolio_assets:
            return """# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
No assets found in portfolio snapshot.

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        result = short_volume.get_portfolio_short_analysis(portfolio_assets)
        
        if not result.get('success'):
            error_msg = result.get('error', 'Unknown error')
            help_text = result.get('help', '')
            
            if result.get('unmapped_stocks'):
                unmapped_list = "\n".join([f"- {stock}" for stock in result['unmapped_stocks']])
                return f"""# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
{error_msg}

**Unmapped stocks:**
{unmapped_list}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
            
            return f"""# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
{error_msg}

{help_text}

*Data provided by [Fintel.io](https://fintel.io)*"""
        
        output_lines = [
            "# ðŸ“Š Portfolio Short Volume Analysis",
            "",
            "## Summary",
            "",
            f"**Stocks Analyzed:** {result.get('stocks_analyzed', 0)}",
            f"**Stocks with Data:** {result.get('stocks_with_data', 0)}",
            f"**Average Short Ratio:** {result.get('avg_short_ratio', 0):.2f}%",
            "",
            f"**High Risk Stocks:** {result.get('high_risk_count', 0)}",
            f"**Medium Risk Stocks:** {result.get('medium_risk_count', 0)}",
            f"**Low Risk Stocks:** {result.get('low_risk_count', 0)}",
            "",
        ]
        
        by_risk = result.get('by_risk', {})
        
        if by_risk.get('high'):
            output_lines.append("## ðŸ”´ High Risk (Elevated Short Activity)")
            output_lines.append("")
            
            for stock_data in by_risk['high']:
                ticker = stock_data.get('ticker', 'Unknown')
                metrics = stock_data.get('metrics', {})
                risk = stock_data.get('risk_analysis', {})
                
                output_lines.append(f"### {ticker}")
                output_lines.append(f"- Average Short Ratio: {metrics.get('avg_short_ratio', 0):.2f}%")
                output_lines.append(f"- Trend: {metrics.get('trend', 'Unknown')}")
                output_lines.append(f"- Risk: {risk.get('description', 'Unknown')}")
                if risk.get('factors'):
                    for factor in risk['factors']:
                        output_lines.append(f"  - {factor}")
                output_lines.append("")
        
        if by_risk.get('medium'):
            output_lines.append("## ðŸŸ¡ Medium Risk (Moderate Short Activity)")
            output_lines.append("")
            
            for stock_data in by_risk['medium']:
                ticker = stock_data.get('ticker', 'Unknown')
                metrics = stock_data.get('metrics', {})
                
                output_lines.append(f"### {ticker}")
                output_lines.append(f"- Average Short Ratio: {metrics.get('avg_short_ratio', 0):.2f}%")
                output_lines.append(f"- Trend: {metrics.get('trend', 'Unknown')}")
                output_lines.append("")
        
        if by_risk.get('low'):
            output_lines.append("## ðŸŸ¢ Low Risk (Normal Short Activity)")
            output_lines.append("")
            low_tickers = [s.get('ticker', 'Unknown') for s in by_risk['low']]
            output_lines.append(", ".join(low_tickers[:10]))
            if len(low_tickers) > 10:
                output_lines.append(f"... and {len(low_tickers) - 10} more")
            output_lines.append("")
        
        stocks_no_data = result.get('stocks_no_data', [])
        if stocks_no_data:
            output_lines.append("## No Data Available")
            output_lines.append("")
            output_lines.append(", ".join(stocks_no_data))
            output_lines.append("")
        
        output_lines.append("---")
        output_lines.append(f"**As of:** {result.get('as_of', 'Unknown')}")
        output_lines.append("")
        output_lines.append("*Data provided by [Fintel.io](https://fintel.io)*")
        
        return "\n".join(output_lines)
        
    except Exception as e:
        error_msg = f"Failed to get portfolio short analysis: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return f"""# ðŸ“Š Portfolio Short Volume Analysis

## âŒ Error
{error_msg}

*Data provided by [Fintel.io](https://fintel.io)*"""


def _run_weekly_analysis() -> str:
    """
    Core function that performs the weekly portfolio analysis workflow.
    
    Returns:
        str: Result message
    """
    try:
        logger.info("Starting weekly portfolio analysis...")
        
        # Get the previous snapshot
        previous_snapshot = storage.get_latest_snapshot()
        
        # Fetch and normalize current portfolio data
        logger.info("Fetching portfolio data from Google Sheets...")
        raw_data = sheets_connector.fetch_portfolio_data()
        normalized_data = sheets_connector.parse_and_normalize_data(raw_data)
        
        # Create new snapshot
        logger.info("Creating portfolio snapshot...")
        current_snapshot = analysis.create_portfolio_snapshot(normalized_data)
        
        # Save the snapshot immediately
        storage.save_snapshot(current_snapshot)
        logger.info("Snapshot saved successfully")
        
        # If we have a previous snapshot, perform comparison
        if previous_snapshot:
            logger.info("Performing week-over-week comparison...")
            report_data = analysis.compare_snapshots(current_snapshot, previous_snapshot)
            
            # Generate markdown report
            current_total_value = current_snapshot.get('total_value_eur', 0.0)
            markdown_report = reporting.format_report_markdown(report_data, current_total_value, current_snapshot)
            
            logger.info("Weekly analysis completed successfully")
            return markdown_report
        else:
            # First run
            current_total_value = current_snapshot.get('total_value_eur', 0.0)
            first_run_message = f"""# ðŸ“Š Portfolio Tracking Initialized

**Initial Portfolio Value:** â‚¬{current_total_value:,.2f}
**Assets Tracked:** {len(normalized_data)}
**Timestamp:** {current_snapshot.get('timestamp', 'Unknown')}

This is the first snapshot of your portfolio. Weekly comparison reports will be available starting next week.

---
*Report generated automatically by Investment MCP Agent*"""
            
            logger.info("First portfolio snapshot created successfully")
            return first_run_message
            
    except Exception as e:
        error_msg = f"Weekly analysis failed: {str(e)}"
        logger.error(error_msg, exc_info=True)
        raise


if __name__ == "__main__":
    # For testing purposes, you can run the analysis directly
    try:
        result = _run_weekly_analysis()
        print(result)
    except Exception as e:
        print(f"Error: {e}")